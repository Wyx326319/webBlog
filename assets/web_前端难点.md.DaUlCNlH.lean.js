import{_ as e,c as t,a2 as o,o as r}from"./chunks/framework.BQmytedh.js";const p=JSON.parse('{"title":"前端开发常见的难点","description":"","frontmatter":{},"headers":[],"relativePath":"web/前端难点.md","filePath":"web/前端难点.md","lastUpdated":1734596260000}'),n={name:"web/前端难点.md"};function h(i,a,l,s,d,c){return r(),t("div",null,a[0]||(a[0]=[o('<h1 id="前端开发常见的难点" tabindex="-1">前端开发常见的难点 <a class="header-anchor" href="#前端开发常见的难点" aria-label="Permalink to &quot;前端开发常见的难点&quot;">​</a></h1><h2 id="模仿阿里的文件上传" tabindex="-1">模仿阿里的文件上传 <a class="header-anchor" href="#模仿阿里的文件上传" aria-label="Permalink to &quot;模仿阿里的文件上传&quot;">​</a></h2><p>阿里的文件上传基本上包含了文件上传的所有功能,</p><h2 id="针对echarts第三方图标库做打包优化" tabindex="-1">针对echarts第三方图标库做打包优化 <a class="header-anchor" href="#针对echarts第三方图标库做打包优化" aria-label="Permalink to &quot;针对echarts第三方图标库做打包优化&quot;">​</a></h2><p>我们先来看一下当echarts图标库完整的引入项目打包后的大小。</p><h2 id="无感刷新token" tabindex="-1">无感刷新token <a class="header-anchor" href="#无感刷新token" aria-label="Permalink to &quot;无感刷新token&quot;">​</a></h2><p>我所了解的无感刷新token通常有3种方式，但是我更建议长短token实现</p><h3 id="第一种-请求前拦截请求-判断token是否过期-重新获取token再发送请求" tabindex="-1">第一种 请求前拦截请求，判断token是否过期，重新获取token再发送请求 <a class="header-anchor" href="#第一种-请求前拦截请求-判断token是否过期-重新获取token再发送请求" aria-label="Permalink to &quot;第一种 请求前拦截请求，判断token是否过期，重新获取token再发送请求&quot;">​</a></h3><p>优点： 在请求前拦截，能节省请求，省流量。 缺点： 需要后端额外提供一个token过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败。</p><h3 id="第二种-请求后拦截响应-根据返回结果" tabindex="-1">第二种 请求后拦截响应，根据返回结果 <a class="header-anchor" href="#第二种-请求后拦截响应-根据返回结果" aria-label="Permalink to &quot;第二种 请求后拦截响应，根据返回结果&quot;">​</a></h3><p>优点：不需额外的token过期字段，不需判断时间。 缺点： 会消耗多一次请求，耗流量。</p><h3 id="第三种-长短token" tabindex="-1">第三种 长短token <a class="header-anchor" href="#第三种-长短token" aria-label="Permalink to &quot;第三种 长短token&quot;">​</a></h3><p>优点: 极大的提高接口的安全性,防止拿到一个token一直可以使用。</p>',13)]))}const u=e(n,[["render",h]]);export{p as __pageData,u as default};
